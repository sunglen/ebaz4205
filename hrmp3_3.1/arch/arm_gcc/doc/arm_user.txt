
		TOPPERS/HRMP3カーネル
		ARM依存部 ユーザーズマニュアル

		対応バージョン: Release 3.1.2
		最終更新: 2020年11月6日

このドキュメントは，TOPPERS/HRMP3カーネルのARM依存部を使用するために必
要な事項を説明するものである．

----------------------------------------------------------------------
 TOPPERS/HRMP Kernel
     Toyohashi Open Platform for Embedded Real-Time Systems/
     High Reliable Multiprocessing Profile Kernel

 Copyright (C) 2018-2020 by Embedded and Real-Time Systems Laboratory
             Graduate School of Information Science, Nagoya Univ., JAPAN
 
 上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
 ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
 変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
 (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
     権表示，この利用条件および下記の無保証規定が，そのままの形でソー
     スコード中に含まれていること．
 (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
     用できる形で再配布する場合には，再配布に伴うドキュメント（利用
     者マニュアルなど）に，上記の著作権表示，この利用条件および下記
     の無保証規定を掲載すること．
 (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
     用できない形で再配布する場合には，次のいずれかの条件を満たすこ
     と．
   (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
       作権表示，この利用条件および下記の無保証規定を掲載すること．
   (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
       報告すること．
 (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
     害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
     また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
     由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
     免責すること．
 
 本ソフトウェアは，無保証で提供されているものである．上記著作権者お
 よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
 に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
 アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
 の責任を負わない．
 
 $Id: arm_user.txt 849 2020-11-04 09:09:16Z ertl-hiro $
----------------------------------------------------------------------

○目次

０．本マニュアルの位置づけ
１．ARM依存部の概要
	1.1 ARMコア依存部
２．ターゲット定義事項の規定
	2.1 サポートできる機能
	2.2 メモリオブジェクト管理に関する規定
	2.3 割込み処理に関する規定
	2.4 CPU例外処理に関する規定
	2.5 タイマに関する規定
		2.5.1 MPCoreチップ依存部におけるタイマに関する規定
			2.5.1.1 プライベートタイマでタイムウィンドウタイマを実現
	2.6 その他の規定・制約
３．使用上の注意とヒント
	3.1 MMUの設定
	3.2 その他の設定オプション
４．リファレンス
	4.1 ディレクトリ構成・ファイル構成
	4.2 バージョン履歴


０．本マニュアルの位置づけ

TOPPERS/HRMP3カーネルのARM依存部は，TOPPERS/ASP3カーネル（以下，ASP3カー
ネル）およびTOPPERS/HRP3カーネル（以下，HRP3カーネル）のARM依存部を拡
張する形で開発したものであり，その使用方法もこれらのカーネルのARM依存
部とほぼ同様である．現時点では，ASP3カーネルのARM依存部 ユーザーズマニュ
アルと重複する事項についてはこのマニュアルに記述していないため，このマ
ニュアルを読む際には，ASP3カーネルのマニュアルもあわせて読むこと．


１．ARM依存部の概要

1.1 ARMコア依存部

HRMP3カーネルのARMコア依存部は，ARMv6およびARMv7-Aに準拠したMMUを持つ
プロセッサコアを持つターゲットシステム（チップ）に共通に使用できる部分
である．

現時点では，GNU開発環境のみに対応している．


２．ターゲット定義事項の規定

2.1 サポートできる機能

ARMコア依存部では，自動メモリ配置と手動メモリ配置の両方に対応している．
また，ATT_MODとATT_PMAをサポートしている．

2.2 メモリオブジェクト管理に関する規定

ARMのMMUでは，ページサイズは4KBである．メモリリージョンの先頭番地とサ
イズは，ページサイズの倍数でなければならない．そのため，ATT_REGで登録
するメモリ領域の先頭番地とサイズも，ページサイズの倍数でなければならな
い．そうでない場合は，E_PARエラーとなる．

また，メモリ保護の単位となるメモリオブジェクトの先頭番地とサイズも，ペー
ジサイズの倍数でなければならない．そのため，ATT_MEM／ATT_PMAで登録する
メモリ領域の先頭番地とサイズ，ATT_PMAで指定する登録するメモリ領域の物
理アドレス空間における先頭番地も，ページサイズの倍数でなければならない．
そうでない場合は，E_PARエラーとなる．

タスクのユーザスタック領域は，そのタスクからだけではなく，それが属する
保護ドメイン全体からアクセスできるものとしている．ユーザスタックのオー
バフローを確実に検出するために，レッドゾーン方式を用いている．

ARMのMMUでは，メモリ領域に対する読出しアクセスは，単独では制御できない．
そのため，メモリオブジェクト属性にTA_NOREADを設定した場合や，アクセス
許可ベクタで書込みアクセス許可・読出しアクセス禁止に設定した場合，コン
フィギュレータは警告メッセージを出して，読出しアクセス禁止の設定を無視
する．ただし，メモリオブジェクトとして登録されないメモリ領域
（TA_NOWRITE属性とTA_NOREAD属性を指定し，TA_EXEC属性を指定しないメモリ
領域）に対するTA_NOREADの指定は有効である．

ARMはショートデータ領域を用いないため，ARMコア依存部では，メモリオブジェ
クト属性のTA_SDATA属性はサポートしていない．

ARMコア依存では，MMUのページテーブルに設定するアクセス属性を，メモリオ
ブジェクト属性から決定している．そこで，ターゲット定義のメモリオブジェ
クト属性として，次の3つを追加している．

	TA_SORDER		0x100		ストロングオーダアクセス
	TA_WTHROUGH		0x200		ライトスルーキャッシュ
	TA_NONSHARED	0x400		プロセッサ間で非共有

これらのメモリオブジェクト属性はすべて，メモリオブジェクトアクセス属性
に該当する．

ARM MMUのページテーブルに設定するアクセス属性は，メモリオブジェクトア
クセス属性（およびアクセス許可ベクタ）から，次のように定める．

・APビット（Access Permission）は，TA_NOWRITE属性と，ユーザドメインか
  らどのようなアクセスが許可されているか（アクセス許可ベクタで判定）か
  ら，次の表に従って設定する．

	TA_NOWRITE		アクセス許可			|	AP
	----------------------------------------+-------
	設定あり		読出し許可				|	111
	設定あり		アクセス不可			|	101
	設定なし		書込み／読出し許可		|	011
	設定なし		読出し許可				|	010
	設定なし		アクセス不可			|	010

・TEX,C,Bビット（Memory Region Attribute）は，TA_SRODER属性，TA_IODEV
  属性，TA_UNCACHE属性，TA_WTHROUGH属性の4つの属性から，次の表に従って
  設定する．

	TA_SRODER	TA_IODEV	TA_UNCACHE	TA_WTHROUGH	|	TEX[2:0],C,B
	------------------------------------------------+---------------
	設定あり	−			−			−			|	000,0,0
	設定なし	設定あり	−			−			|	000,0,1(*1)
	設定なし	設定なし	設定あり	−			|	001,0,0
	設定なし	設定なし	設定なし	設定あり	|	000,1,0
	設定なし	設定なし	設定なし	設定なし	|	001,1,1

  (*1) TA_NONSHARED属性が設定されている場合には，010,0,0とする．

・XNビット（Execute-Never）は，TA_EXEC属性が設定されている場合には0に，
  そうでない場合には1に設定する．

・Sビット（Shareable）は，TA_NONSHARED属性が設定されている場合には0に，
  そうでない場合には1に設定する．

・nGビット（Not Global）は，通常操作1と通常操作2のアクセス許可パターン
  がいずれもTACP_KERNELまたはTACP_SHAREDであれば0に，そうでない場合に
  は1に設定する．

2.3 割込み処理に関する規定

ARMコア依存部では，割込み番号と割込みハンドラ番号を，次のように付与し
ている．

複数のプロセッサに接続された割込み要求ラインに対しては，割込み番号の上
位16ビットを0とし，下位16ビットで，その中のどの割込み要求ラインである
かを識別する．また，1つのプロセッサのみに接続された割込み要求ラインに
対しては，割込み番号の上位16ビットを，接続されたプロセッサのID番号とし，
下位16ビットで，その中のどの割込み要求ラインであるかを識別する．

割込みハンドラはプロセッサ毎に登録することから，同じ割込み要求に対応す
る割込みハンドラであっても，プロセッサ毎に異なる割込みハンドラ番号を付
与する必要がある．そこで，割込みハンドラ番号の上位16ビットを，その割込
みハンドラを実行するプロセッサのID番号とし，下位16ビットで，その中でど
の割込みハンドラであるかを識別する．

2.3.1 GIC依存部における割込み処理に関する規定

GICがサポートする割込みの種類と，GICに対する割込みのID番号の範囲は次の
通り．

	0〜15				ソフトウェア生成割込み（SGI）
	16〜31				コア毎のペリフェラルからの割込み（PPI）
	32〜1019（最大）	共有ペリフェラルからの割込み（SPI）

GIC依存部では，SPIを複数のプロセッサに接続された割込み要求ライン，SGI
とPPIを，1つのプロセッサのみに接続された割込み要求ラインと扱う．また，
GICに対する割込みのID番号を，割込み番号および割込みハンドラ番号の下位
16ビットに使用している．

例えば，プロセッサ1に対するID番号が16（＝0x10）のPPIの場合，割込み番号，
割込みハンドラ番号とも0x10010になる．また，ID番号が32（＝0x20）のPPIの
場合，割込み番号が0x20に，プロセッサ1に対する割込みハンドラ番号が
0x10020になる．

GICは，割込み（SPI）を複数のプロセッサに対して要求し，最初に割込みを受
け付けたプロセッサがそれを処理する機能を持つ．ただし，GIC依存部は現時
点ではこの機能をサポートしておらず（動作するはずであるが，テストしてい
ない），割付け可能プロセッサが複数あるクラスの囲み内にCFG_INTを記述し
た場合には，コンフィギュレータがE_RSATRエラーを報告する．

GIC依存部では，割込みの禁止（dis_int），割込みの許可（ena_int），割込
み要求のクリア（clr_int），割込みの要求（ras_int），割込み要求のチェッ
ク（prb_int）では，以下の例外を除いて，複数のプロセッサに接続された割
込み要求ラインと，サービスコールを呼び出したプロセッサのみに接続された
割込み要求ラインのみを操作対象にできる．この制約に合致せずにこれらのサー
ビスコールを呼び出した場合，E_PARエラーとなる．

・dis_int，ena_int
	SGIに対するdis_int／ena_intがサポートされるかは，チップに依存する．
	サポートする場合には，ターゲット依存部で，GIC_SUPPORT_DISABLE_SGI
	をマクロ定義する．

・clr_int
	SGIに対する割込み要求のクリアはサポートしていない（GICのバージョン
	によってはサポートできないため）．

・ras_int
	他のプロセッサに接続されたSGIに対して，割込みを要求できる．

なお，レベルトリガの割込み要求ラインに対しても，ras_intで割込みを要求
することができ，clr_intは，ras_intで要求した割込み要求のみをクリアする
（ハードウェアからレベルトリガで要求された割込み要求はクリアできない）．

2.4 CPU例外処理に関する規定

異なるプロセッサで発生するCPU例外は異なるCPU例外であると扱い，CPU例外
ハンドラはプロセッサ毎に登録することから，同じ種類のCPU例外であっても，
プロセッサ毎に異なるCPU例外ハンドラ番号を付与する必要がある．そこで，
ARMコア依存部では，CPU例外ハンドラ番号の上位16ビットを，そのCPU例外ハ
ンドラを実行するプロセッサのID番号とし，下位16ビットで，以下の中のどの
CPU例外ハンドラであるかを識別する．

	EXCNO_UNDEF		0		未定義命令
	EXCNO_SVC		1		スーパバイザコール
	EXCNO_PABORT	2		プリフェッチアボート
	EXCNO_DABORT	3		データアボート
	EXCNO_IRQ		4		IRQ割込み
	EXCNO_FIQ		5		FIQ割込み
	EXCNO_FATAL		6		フェイタルデータアボート
	EXCNO_SCYCOVR	7		システム周期オーバラン例外

この中で，フェイタルデータアボートとシステム周期オーバラン例外は，エミュ
レートされたCPU例外である．

ARMコア依存部では，ソフトウェア割込みによるサービスコール呼出しに，svc
命令（スーパバイザコール命令）を用いている．その際，svc命令のオペラン
ド（即値）を，SVC_SERVICE_CALL（＝1）としている．また，システム周期オー
バラン例外の発生にも，オペランドをSVC_SCYCOVR（＝2）とするsvc命令を用
いている．

そのため，スーパバイザコール（EXCNO_SVC）に対してDEC_EXCにより登録した
CPU例外ハンドラが実行されるのは，上記の2つ以外の値をオペランドとして
svc命令を発行した場合のみである．

ARMでは，許可されていない実行アクセスを行おうとした場合，プリフェッチ
アボート（EXCNO_PABORT）が発生する．また，許可されていない書込みアクセ
スまたは読出しアクセスを行おうとした場合，データアボート（EXCNO_DABORT）
が発生する．これらに対してDEC_EXCにより登録したCPU例外ハンドラで，アク
セス違反に対する例外処理を行うことができる．

フェイタルデータアボート（EXCNO_FATAL）は，カーネル内のCPU例外入口処理
においてデータアボートが発生した場合に発生するエミュレートされたCPU例
外である．具体的には，スタックポインタが不正な値になった状態でCPU例外
が発生すると，CPU例外の入口処理で必要な情報をスタックに保存しようとし
て，再度CPU例外が発生する．これがフェイタルデータアボートである．フェ
イタルデータアボートは，カーネル管理外のCPU例外である．フェイタルデー
タアボートのCPU例外ハンドラからは，リターンしてはならない．

システム周期オーバラン例外に対するCPU例外ハンドラを定義する場合には，
CPU例外ハンドラ番号をEXCNO_SCYCOVR（＝7）として，DEF_EXCにより登録する．

2.5 タイマに関する規定

2.5.1 MPCoreチップ依存部におけるタイマに関する規定

MPCore依存部では，プロセッサ毎に持つプライベートタイマとウォッチドッグ，
各プロセッサからアクセスできるグローバルタイマを用いて，カーネルが必要
とする3種類のタイマを実現している．具体的には，以下の4種類の使用方法を
サポートしている．

 (a) プライベートタイマとウォッチドッグで高分解能タイマを実現
 (b) グローバルタイマで高分解能タイマを実現
 (c) プライベートタイマでタイムウィンドウタイマを実現
 (d) ウォッチドッグでオーバランタイマを実現

この内，(a)(b)(d)は，ASP3カーネルにおける(a)(b)(c)と同じであるため，以
下では，(c)の使用方法について説明する．なお，(b)と(c)と(d)は同時に用い
ることができる．

2.5.1.1 プライベートタイマでタイムウィンドウタイマを実現

プライベートタイマを用いて，タイムウィンドウタイマを実現する．

プライベートタイマのクロック源の周波数が256MHz以下の場合には，プリスケー
ラを用いて1MHzのクロックを作り，プライベートタイマを1MHzで駆動する．こ
の場合には，ターゲット依存部でmpcore_timer.hをインクルードする前に，次
のマクロを定義する必要がある．

	USE_MPCORE_TMW_TWDTIMER プライベートタイマでオーバランタイマを実現
							することを指定
	MPCORE_TMR_PS_VALUE		プライベートタイマのプリスケーラの設定値

プリスケーラの設定値は，分周比（クロック源のMHz単位での周波数）から1を
減じたものに定義する．

プライベートタイマのクロック源の周波数が256MHzを超える場合には，プリス
ケーラで1MHzのクロックを作ることができない．そこで，プリスケーラで作る
ことができる1MHzの倍数の周波数（これを，N MHzとする）を選び，プライベー
トタイマをN MHzで駆動する．この時，target_kernel.h（または，そこからイ
ンクルードされるファイル）で定義すべきタイムウィンドウの長さに指定でき
る最大値（TMAX_TWDTIM）は，2^32/N（小数点以下は切り捨て）になる．また，
ターゲット依存部でmpcore_timer.hをインクルードする前に，上述のマクロに
加えて，次のマクロを定義する必要がある．

	MPCORE_TMR_FREQ			プライベートタイマの駆動周波数

2.6 その他の規定・制約

タスクのユーザスタック領域の先頭番地とサイズは，4096（4K）の倍数でなけ
ればならない．タスクのシステムスタック領域と非タスクコンテキスト用のス
タック領域の先頭番地とサイズは，8の倍数でなければならない．

ターゲット定義の予約セクションとして，次の6種類のセクションを使用する．
これらをATT_SECで登録することはできない．

	.kernel_data_<クラス名>		各クラスに属するカーネルオブジェクトの
								管理ブロックや管理領域等を配置するセク
								ション
	.system_stack_<クラス名>	各クラスに属するタスクのシステムスタッ
								ク領域や非タスクコンテキスト用のスタッ
								ク領域等を配置するセクション
	.ustack_<タスク名>			ユーザスタック領域を配置するセクション
	.mpf_<固定長メモリプール名>	固定長メモリプール領域を配置するセクション
	.page_table					アドレス変換テーブルを配置するセクション
	.shared_code				すべての保護ドメインから呼び出すコード
								（共有ライブラリ）を配置するセクション


３．使用上の注意とヒント

3.1 MMUの設定

HRMP3カーネルでは，MMUの設定はARMコア依存部で行うため，ASP3カーネルの
ARM依存部 ユーザーズマニュアルの「3.1 MMUの設定」の節の内容は適用され
ない．ARMコア依存部を使用するターゲット依存部では，ターゲットのメモリ
構成を，静的APIの形でtarget_mem.cfgに記述すればよい．

3.2 その他の設定オプション

ARMv7以降のコアには，スレッドIDレジスタが用意されている．HRMP3カーネル
のARM依存部は，USE_THREAD_ID_PCBをマクロ定義することで，特権モード専用
のスレッドIDレジスタ（TPIDRPRW）にプロセッサ管理ブロックへのポインタを
格納することで，処理を効率化する．スレッドIDレジスタが用意されているター
ゲットシステムでは，ターゲット依存部でUSE_THREAD_ID_PCBをマクロ定義す
る方が良い．

ARMv6KおよびARMv7以降のコアでは，スピンロック取得時に，単純にループす
るのではなく，WFE命令を用いてイベント待ちとすることが推奨されている．
HRMP3カーネルのARM依存部は，WFE命令を用いてイベント待ちとする実装を行っ
ているが，この命令をサポートしていないターゲットシステムでは，ターゲッ
ト依存部でTOPPERS_OMIT_USE_WFEをマクロ定義する必要がある．


４．リファレンス

4.1 ディレクトリ構成・ファイル構成

	arm_gcc/
		E_PACKAGE				簡易パッケージのファイルリスト
		MANIFEST				個別パッケージのファイルリスト

	arm_gcc/common/
		Makefile.core			Makefileのコア依存部
		arm.c					コアのハードウェア資源の操作
		arm.h					コアのハードウェア資源の定義
		arm_insn.h				コア独自の命令の実行
		arm_mmu.trb				ARM MMUのアドレス変換テーブルの作成
		cfg1_out.ld				パス1のためのリンカスクリプト
		core_asm.inc			アセンブラ記述のためのマクロ
		core_cfg1_out.h			cfg1_out.cのリンクに必要なスタブの定義
		core_check.trb			kernel_check.trbのコア依存部
		core_kernel.h			kernel.hのコア依存部
		core_kernel.trb			kernel.trbのコア依存部
		core_kernel_impl.c		カーネル実装のコア依存部関連の定義
		core_kernel_impl.h		カーネル実装のコア依存部
		core_ldscript.trb		コア依存のリンカスクリプトの生成
		core_mem.trb			パス4の生成スクリプトのコア依存部
		core_offset.trb			genoffset.trbのコア依存部
		core_opt.trb			パス3の生成スクリプトのコア依存部
		core_pcb.h				プロセッサコントロールブロックのコア依存部
		core_rename.def			コア依存部の内部識別名のリネーム定義
		core_rename.h			コア依存部の内部識別名のリネーム
		core_sil.h				sil.hのコア依存部
		core_stddef.h			t_stddef.hのコア依存部
		core_support.S			カーネル実装のコア依存部（アセンブリ言語
								で記述した部分）
		core_svc.h				ソフトウェア割込みによるサービスコール呼
								出しのコア依存部
 		core_sym.def			kernel_sym.defのコア依存部
		core_syssvc.h			システムサービスのコア依存定義
		core_test.h				テストプログラムのコア依存定義
		core_unrename.h			コア依存部の内部識別名のリネーム解除
		gic_ipi.cfg				GIC用のプロセッサ間割込みのコンフィギュ
								レーションファイル
		gic_ipi.h				GIC用のプロセッサ間割込みに関する定義
		gic_kernel.trb			パス2の生成スクリプトのGIC依存部
		gic_kernel_impl.c		カーネル実装のGIC依存部関連の定義
		gic_kernel_impl.h		カーネル実装のGIC依存部
		gic_support.S			カーネル実装のGIC依存部関連（アセンブリ言
								語で記述した部分）
		mpcore.h				MPCoreのハードウェア資源の定義
		mpcore_kernel_impl.c	カーネル実装のMPCore依存部
		mpcore_kernel_impl.h	カーネル実装のMPCore依存部関連の定義
		mpcore_timer.c			MPCore内蔵タイマ用のタイマドライバ
		mpcore_timer.cfg		MPCore内蔵タイマ用のタイマドライバのコンフィ
								ギュレーションファイル
		mpcore_timer.h			MPCore内蔵タイマ用のタイマドライバ関連の定義
		pl310.c					L2キャッシュコントローラ（PL310）の操作ライ
								ブラリ
		pl310.h					L2キャッシュコントローラ（PL310）に関する定義
		start.S					カーネル用のスタートアップモジュール（ARM用）

	arm_gcc/doc/
		arm_user.txt			ARM依存部 ユーザーズマニュアル

	arm_gcc/test/			ARM向けテストプログラム
		arm_cpuexc.c			ARM向けCPU例外処理のテスト
		arm_cpuexc.cfg
		arm_fpu1.c				ARM向けFPUのテスト(1)
		arm_fpu1.cfg

4.2 バージョン履歴

	2019年3月28日	Release	3.0.0		最初の一般公開
	2019年10月6日	Release 3.1.0
	2020年3月31日	Release 3.1.1
	2020年11月6日	Release 3.1.2

以上
